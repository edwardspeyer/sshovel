#!/usr/bin/env python
"""
ssh-crypt: encrypt and decrypt files using ssh keys

References:

[1] SSH Agent Protocol
Damien Miller, IETF
https://tools.ietf.org/id/draft-miller-ssh-agent-00.html

[2] ssh-crypt: encrypt secrets with the SSH Agent
Leigh McCulloch
https://github.com/leighmcculloch/sshcrypt

[3] Twisted Conch: an SSHv2 implementation written in Python
http://twistedmatrix.com/documents/8.2.0/api/twisted.conch.ssh.keys.Key.html#blob

[4] Stack Overflow: Creating a rsa public key from its modulus and exponent
@qualcuno and @oliv
https://stackoverflow.com/questions/11541192

[5] Encryption with RSA Key Pairs
Kris Jordan
http://krisjordan.com/essays/encrypting-with-rsa-key-pairs

[6] Convert an ssh-keygen public key into OpenSSL PEM format
https://unix.stackexchange.com/a/358709/233034
"""

from collections import namedtuple
import StringIO
import argparse
import atexit
import fcntl
import hashlib
import os
import os.path
import pty
import re
import shutil
import signal
import socket
import struct
import subprocess
import sys
import tempfile
import time
import unittest


class UserException(Exception):
    """
    Exception for alerting the user with messages (and not full stack traces.)
    """
    pass


def log(message):
    script = os.path.basename(sys.argv[0])
    message = "{}: {}\n".format(script, message)
    sys.stderr.write(message)


def assert_exists(path):
    """
    Check file exists and is a file, or alert the user.
    """
    if not os.path.exists(path):
        raise UserException('file not found: {}'.format(path))
    if os.path.isdir(path):
        raise UserException('exists, but is a directory: {}'.format(path))


class Packer(object):
    """
    Pack and unpack length prefixed binary data, as defined by the SSH
    standards.
    """

    @staticmethod
    def byte(a_byte):
        return struct.pack('>B', a_byte)

    @staticmethod
    def long(a_long):
        return struct.pack('>L', a_long)

    @staticmethod
    def string(a_string):
        length = len(a_string)
        template = '>L{}s'.format(length)
        return struct.pack(template, length, a_string)

    @classmethod
    def from_socket(cls, a_socket):
        return cls(a_socket.recv, a_socket.sendall)

    @classmethod
    def from_file(cls, a_file):
        return cls(a_file.read, a_file.write)

    def __init__(self, read_fn, write_fn):
        self.read_fn = read_fn
        self.write_fn = write_fn

    def write(self, *values):
        body = ''.join(values)
        length = len(body)
        self.write_fn(self.long(length))
        self.write_fn(body)

    def read_byte(self):
        return self.unpack(1, '>B')

    def read_long(self):
        return self.unpack(4, '>L')

    def read_string(self):
        length = self.read_long()
        template = '{}s'.format(length)
        return self.unpack(length, template)

    def unpack(self, length, template):
        some_bytes = self.read_fn(length)
        return struct.unpack(template, some_bytes)[0]


class PackerTest(unittest.TestCase):
    def test_read_then_write(self):
        message = "Hello, world!"
        sio = StringIO.StringIO()
        pack = Packer.from_file(sio)
        pack.write(pack.byte(99), pack.string(message))
        sio.seek(0)
        self.assertEqual(pack.read_long(), 18, "total pack length")
        self.assertEqual(pack.read_byte(), 99, "packed byte")
        self.assertEqual(pack.read_string(), message, "packed string")


class SSHAgentConnection(object):
    """
    Interface to a running ssh-agent(1)
    """

    Key = namedtuple('Key', 'blob comment')

    # https://tools.ietf.org/id/draft-miller-ssh-agent-00.html
    AGENTC_REQUEST_IDENTITIES = 11
    AGENT_IDENTITIES_ANSWER = 12
    AGENTC_SIGN_REQUEST = 13
    AGENT_SIGN_RESPONSE = 14
    AGENT_RSA_SHA2_256 = 2
    AGENT_RSA_SHA2_512 = 4

    def __init__(self, socket_path):
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
        sock.connect(socket_path)
        self.packer = Packer.from_socket(sock)

    def identities(self):
        self.packer.write(
            self.packer.byte(SSHAgentConnection.AGENTC_REQUEST_IDENTITIES))
        _ = self.packer.read_long()  # length
        response = self.packer.read_byte()
        assert response == SSHAgentConnection.AGENT_IDENTITIES_ANSWER
        num_keys = self.packer.read_long()
        result = []
        for _ in range(num_keys):
            blob = self.packer.read_string()
            comment = self.packer.read_string()
            key = SSHAgentConnection.Key(blob, comment)
            result.append(key)
        return result

    def sign(self, key, message, flags=0):
        self.packer.write(
            self.packer.byte(SSHAgentConnection.AGENTC_SIGN_REQUEST),
            self.packer.string(key.blob),
            self.packer.string(message),
            self.packer.long(flags)
        )
        _ = self.packer.read_long()  # length
        response = self.packer.read_byte()
        assert response == SSHAgentConnection.AGENT_SIGN_RESPONSE
        signature = self.packer.read_string()
        return signature


class SSHTestFixture(object):
    """
    Set up a real ssh-agent(1) and load it with a test key, and provide a way
    to kill the agent.
    """

    TEST_KEY = """
-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQD0OCPZ50akyXxhyFz/JdCTZISvHJ+nFOnXMHKQzF3Q3fAbXGVM
jEU2Wer+owj6s4wxuNmd6g3XAyyomCSRoxE6txNpQ10Yay4ZUMhO3XDr3zN5WBhd
6dqDjNLsrfu5mjy9aWFZDpBYnmRnOQBeLGxNQE6shbwOAzsixirmiUyXBQIDAQAB
AoGAZwCallgGIpBcZn10Q6S2UMQPdi/TYkveyITFfS7Ezsgccd3JV7y9oEvSYi1v
JxW9Jmd5WTITPkE3f7ATlF07cT5EZaHPMHm02GJegopN1AW2caoN2N+FHpe2cnOW
0vLtV+dQ0j5QnCWOfPpM70wYqEwvO+tC9uIaIOCBVTdyF20CQQD7IxTeZjiirZ0M
SlSPZmNRlFBRUkHjc4I7A5weV5L5YR/LWN2W/RL0j+v60L18Uld0pGcDuYX1Fg42
oUYEazaLAkEA+PLEMtU7vh3d9PtyDyIG7prcAJnUljwybRgZoVQNMsMxxONbSoAb
B9tw8irock7zjkPYsqvjSAxcfV1I+J6qrwJBAJaFQEzMF8XpKOfk5SnNxFlw+3LC
Spt47+VPFJNbCcxOWjAW4zlMFcBfQqDh27BX6fMPVm71E0UCIyK7JqwfVmECQAJ8
8qcLaIhy5ff/11j9XxJda9t5rh0+Rsa+Wes52tPqDYJJP21UMHD4qX1SHnaeAWMn
nG/UtfXPYdFC8GrDszMCQHNHjkRPhgnFKZBIqg6CjWE0wVWdZRWwLrP7a2YQsX4A
aZkvLueqxAr5SzU9sTiL6tBQAEaESEHOTm11g+IRmFA=
-----END RSA PRIVATE KEY-----
"""

    def __init__(self):
        self.start_agent()
        self.load_keys()

    def start_agent(self):
        output = subprocess.check_output('ssh-agent')
        self.socket_path = re.search('SSH_AUTH_SOCK=(.+?);', output).group(1)
        pid_str = re.search(r'SSH_AGENT_PID=(\d+)', output).group(1)
        self.agent_pid = int(pid_str)

    def load_keys(self):
        key_name = 'a_test_ssh_key'
        key_file = tempfile.NamedTemporaryFile(prefix=key_name + '.')
        key_file.write(self.TEST_KEY)
        key_file.flush()
        ssh_add_env = dict(os.environ)
        ssh_add_env['SSH_AUTH_SOCK'] = self.socket_path
        subprocess.check_output(
            ['ssh-add', key_file.name],
            env=ssh_add_env,
            stderr=subprocess.PIPE)

    def stop(self):
        os.kill(self.agent_pid, signal.SIGKILL)


class SSHAgentConnectionTest(unittest.TestCase):
    def setUp(self):
        self.ssh_fixture = SSHTestFixture()

    def test_identities(self):
        ssh = SSHAgentConnection(self.ssh_fixture.socket_path)
        keys = ssh.identities()
        self.assertEqual(len(keys), 1, "number of keys loaded in agent")

    def test_sign(self):
        ssh = SSHAgentConnection(self.ssh_fixture.socket_path)
        key = ssh.identities()[0]
        message = "Hello, world!"
        expected_digest = "791c659db0f314126ff0226beaa25aa6b8c4f00e"
        for _ in range(0, 3):
            signature = ssh.sign(key, message)
            actual_digest = hashlib.sha1(signature).hexdigest()
            self.assertEqual(expected_digest, actual_digest)

    def tearDown(self):
        self.ssh_fixture.stop()


class Encryptor(object):
    def encrypt(self, in_file, out_file, passphrase):
        pass

    def decrypt(self, in_file, out_file, passphrase):
        pass

    @staticmethod
    def all_encryptor_names():
        return [
            cls.__name__.lower()
            for cls in Encryptor.__subclasses__()]

    @staticmethod
    def instance_of(name):
        for cls in Encryptor.__subclasses__():
            if cls.__name__.lower() == name.lower():
                return cls()
        raise UserException("unknown encryptor '{}'".format(name))

class Rot13(Encryptor):
    def encrypt(self, in_file, out_file, passphrase):
        digest = hashlib.sha1(passphrase).hexdigest()
        tmp = tempfile.NamedTemporaryFile()
        self._rot13(in_file, tmp.name)
        with open(out_file, 'w') as f:
            f.write(digest)
            shutil.copyfileobj(tmp, f)

    def decrypt(self, in_file, out_file, passphrase):
        digest = hashlib.sha1(passphrase).hexdigest()
        tmp = tempfile.NamedTemporaryFile()
        with open(in_file) as f:
            _ = f.read(len(digest))  # Read the digest
            shutil.copyfileobj(f, tmp)
        tmp.flush()
        return self._rot13(tmp.name, out_file)

    @staticmethod
    def _rot13(in_file, out_file):
        script = 'tr a-zA-Z n-za-mA-ZA-M <{} >{}'.format(in_file, out_file)
        subprocess.check_call(script, shell=True)


class Rot13Test(unittest.TestCase):
    def test_encrypt_then_decrypt(self):
        message = 'Hello, world!'
        passphrase = 'PASSPHRASE'
        files = TestFiles(message)
        encryptor = Rot13()
        encryptor.encrypt(files.f0.name, files.f1.name, passphrase)
        encryptor.decrypt(files.f1.name, files.f2.name, passphrase)
        self.assertEqual(message, files.f2.read())


class OpenSSL(Encryptor):
    def encrypt(self, in_file, out_file, passphrase):
        self._openssl('-e', in_file, out_file, passphrase)

    def decrypt(self, in_file, out_file, passphrase):
        self._openssl('-d', in_file, out_file, passphrase)

    @staticmethod
    def _openssl(command, in_file, out_file, passphrase):
        tmp = tempfile.NamedTemporaryFile()
        tmp.write(passphrase)
        tmp.flush()
        command = [
            'openssl', 'aes-256-cbc',
            command,
            '-a', '-salt',
            '-kfile', tmp.name,
            '-in', in_file,
            '-out', out_file]
        subprocess.check_call(command)


class Scrypt(Encryptor):
    """
    Interface to the scrypt(1) command line tool.
    """

    def encrypt(self, in_file, out_file, passphrase):
        assert_exists(in_file)
        pid, fd = self._fork('enc', in_file, out_file)
        self._send_passphrase(fd, passphrase)
        self._send_passphrase(fd, passphrase)
        log("encrypting with scrypt...")
        os.waitpid(pid, 0)
        log("done!")

    def decrypt(self, in_file, out_file, passphrase):
        assert_exists(in_file)
        pid, fd = self._fork('dec', in_file, out_file)
        self._send_passphrase(fd, passphrase)
        log("decrypting with scrypt...")
        os.waitpid(pid, 0)
        log("done!")

    @staticmethod
    def _fork(command, in_file, out_file):
        pid, fd = pty.fork()
        if pid == 0:
            os.execlp('scrypt', 'scrypt', command, in_file, out_file)
        fcntl.fcntl(fd, fcntl.F_SETFL, os.O_NONBLOCK)
        return pid, fd

    def _send_passphrase(self, fd, passphrase):
        self._expect(fd, "passphrase: ", 1)
        os.write(fd, passphrase)
        os.write(fd, "\n")
        os.fsync(fd)
        self._expect(fd, "\r\n", 1)

    @staticmethod
    def _expect(fd, phrase, timeout):
        start_time = time.time()
        buf = []
        while 1:
            try:
                byte = os.read(fd, 1)
                if byte == '':
                    msg = "EOF after reading: " + ''.join(buf)
                    raise UserException(msg)
                buf.append(byte)
            except OSError:
                duration = time.time() - start_time
                if duration > timeout:
                    msg = "timed out waiting for '{}'".format(phrase)
                    raise UserException(msg)
                time.sleep(0.1)
            if ''.join(buf).endswith(phrase):
                return


class TestFiles(object):
    """
    Some test files, the first of which contains a known message.  Useful when
    testing encrypt(f1, f2) and decrypt(f2, f3).
    """

    def __init__(self, message):
        self.f0 = tempfile.NamedTemporaryFile()
        self.f1 = tempfile.NamedTemporaryFile()
        self.f2 = tempfile.NamedTemporaryFile()
        self.f0.write(message)
        self.f0.flush()


class ScryptTest(unittest.TestCase):
    def test_encrypt_then_decrypt(self):
        message = "Hello, world!"
        passphrase = 'PASSPHRASE'
        files = TestFiles(message)
        scrypt = Scrypt()
        scrypt.encrypt(files.f0.name, files.f1.name, passphrase)
        scrypt.decrypt(files.f1.name, files.f2.name, passphrase)
        self.assertEqual(message, files.f2.read())


class SSHEncryptor(object):
    """
    Interface to scrypt(1) that uses an ssh-agent(1) to generate the scrypt
    passphrase.
    """

    MAGIC = "HAZ.CAT/SSH-CRYPT"
    VERSION = "V1"

    def encrypt(self, in_file, out_file, ssh, key, encryptor):
        assert_exists(in_file)
        nonce = SSHEncryptor.checksum(in_file)
        signature = ssh.sign(key, nonce)
        passphrase = hashlib.sha1(signature).hexdigest()
        tmp_file = self.tmp_for(out_file)
        encryptor.encrypt(in_file, tmp_file, passphrase)
        with open(out_file, 'w') as out_io:
            out_io.write(self.MAGIC)
            out_io.write(Packer.string(self.VERSION))
            out_io.write(Packer.string(encryptor.__class__.__name__))
            out_io.write(Packer.string(nonce))
            with open(tmp_file) as tmp_io:
                shutil.copyfileobj(tmp_io, out_io)

    def decrypt(self, in_file, out_file, ssh, key):
        assert_exists(in_file)
        tmp_file = self.tmp_for(out_file)
        passphrase = None
        encryptor_name = None
        with open(in_file) as in_io:
            magic = in_io.read(len(self.MAGIC))
            if magic != self.MAGIC:
                raise UserException(
                    "unrecognized format; did not find magic number '{}'"
                    .format(self.MAGIC))
            packer = Packer.from_file(in_io)
            _ = packer.read_string()  # Version, unused.
            encryptor_name = packer.read_string()
            nonce = packer.read_string()
            signature = ssh.sign(key, nonce)
            passphrase = hashlib.sha1(signature).hexdigest()

            with open(tmp_file, 'w') as tmp_io:
                shutil.copyfileobj(in_io, tmp_io)
        encryptor = Encryptor.instance_of(encryptor_name)
        encryptor.decrypt(tmp_file, out_file, passphrase)

    @staticmethod
    def checksum(path):
        sha = hashlib.sha1()
        with open(path, 'rb') as f:
            for block in iter(lambda: f.read(4096), b""):
                sha.update(block)
        return sha.hexdigest()

    @staticmethod
    def tmp_for(path):
        dirname = os.path.dirname(path)
        if dirname == '':
            dirname = '.'
        basename = os.path.basename(path)
        fd, tmp_file = tempfile.mkstemp(prefix='.'+basename, dir=dirname)
        os.close(fd)
        atexit.register(lambda: os.remove(tmp_file))
        return tmp_file


class SSHEncryptorTest(unittest.TestCase):
    def setUp(self):
        self.ssh_fixture = SSHTestFixture()

    def test_encrypt_then_decrypt(self):
        message = "Hello, secret world!"
        files = TestFiles(message)
        ssh = SSHAgentConnection(self.ssh_fixture.socket_path)
        key = ssh.identities()[0]
        encryptor = Rot13()
        SSHEncryptor().encrypt(files.f0.name, files.f1.name, ssh, key, encryptor)
        SSHEncryptor().decrypt(files.f1.name, files.f2.name, ssh, key)
        self.assertEqual(message, files.f2.read())

    def tearDown(self):
        self.ssh_fixture.stop()


def main(args):
    parser = argparse.ArgumentParser(
        description='Encrypt files with passphrases derived from ssh keys.')
    parser.add_argument(
        '--encrypt',
        nargs='*',
        metavar=('IN', 'OUT'),
        help='')
    parser.add_argument(
        '--decrypt',
        nargs='*',
        metavar=('IN', 'OUT'),
        help='')
    parser.add_argument(
        '--key',
        metavar='MATCH',
        help='use the ssh key whose comment matches MATCH')
    parser.add_argument(
        '--encryptor',
        choices=Encryptor.all_encryptor_names(),
        help='encrypt with the given tool, (default: scrypt)')
    parser.add_argument(
        '--test',
        nargs='*',
        metavar='ARGS',
        help='run the test suite')

    args = parser.parse_args(args)

    if args.test is not None:
        unittest_args = [__file__]
        unittest_args.extend(args.test)
        unittest.main(argv=unittest_args)

    if args.encrypt is None and args.decrypt is None:
        parser.error("please select one of --encrypt or --decrypt")

    encryptor = Scrypt()
    if args.encryptor:
        encryptor = Encryptor.instance_of(args.encryptor)

    socket_path = os.environ.get('SSH_AUTH_SOCK')
    if socket_path == "":
        parser.error("SSH_AUTH_SOCK is empty or unset")

    ssh = SSHAgentConnection(socket_path)
    keys = ssh.identities()
    if not keys:
        parser.error("ssh agent has no keys")

    key = keys[0]
    if args.key:
        matches = []
        for candidate in keys:
            if args.key in candidate.comment:
                matches.append(candidate)
        if not matches:
            parser.error(
                "no ssh key matched '{}'; known keys: {}"
                .format(args.key, [k.comment for k in keys]))
        elif len(matches) == 1:
            key = matches[0]
        else:
            parser.error(
                "more than one key matched '{}': {}"
                .format(args.key, [k.comment for k in matches]))

    log("using ssh-agent key: {}".format(key.comment))

    files = args.encrypt or args.decrypt or []
    files.extend(['-', '-'])
    in_file = files[0]
    out_file = files[1]

    in_tmp = None
    if in_file == '-':
        in_tmp = tempfile.NamedTemporaryFile()
        shutil.copyfileobj(sys.stdin, in_tmp)
        in_tmp.flush()
        in_file = in_tmp.name

    out_tmp = None
    if out_file == '-':
        out_tmp = tempfile.NamedTemporaryFile()
        out_file = out_tmp.name

    if args.encrypt is not None:
        SSHEncryptor().encrypt(in_file, out_file, ssh, key, encryptor)
    elif args.decrypt is not None:
        SSHEncryptor().decrypt(in_file, out_file, ssh, key)

    if out_tmp is not None:
        out_tmp.seek(0)
        shutil.copyfileobj(out_tmp, sys.stdout)
        sys.stdout.flush()

class MainTest(unittest.TestCase):
    message = "SUPER SECRET FILE CONTENTS"

    def setUp(self):
        self.files = TestFiles(self.message)
        self.ssh_fixture = SSHTestFixture()
        os.environ['SSH_AUTH_SOCK'] = self.ssh_fixture.socket_path

    def test_encrypt(self):
        main(['--encrypt', self.files.f0.name, self.files.f1.name])
        main(['--decrypt', self.files.f1.name, self.files.f2.name])
        self.assertEqual(self.message, self.files.f2.read())

    def tearDown(self):
        self.ssh_fixture.stop()


try:
    main(sys.argv[1:])
except UserException as ex:
    log(ex.message)
    sys.exit(1)
